线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也
塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。
JDK 内置的拒绝策略如下：
1. AbortPolicy ： 直接抛出异常，阻止系统正常运行。
2. CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的
任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。
3. DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再
次提交当前任务。
4. DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢
失，这是最好的一种方案。
以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际
需要，完全可以自己扩展 RejectedExecutionHandler 接口。
4.1.13.4. Java 线程池工作过程
1.  线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面
有任务，线程池也不会马上执行它们。
2.  当调用 execute() 方法添加一个任务时，线程池会做如下判断：
a)  如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；
b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；
c)  如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要
创建非核心线程立刻运行这个任务；
d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池
会抛出异常 RejectExecutionException。
3.  当一个线程完成任务时，它会从队列中取下一个任务来执行。
4.  当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运
行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它
最终会收缩到 corePoolSize 的大小。
13/04/2018  Page 79 of 283
4.1.14.  JAVA  阻塞队列原理
阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：
1.  当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放
入队列。
2.  当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有
空的位置，线程被自动唤醒。
13/04/2018  Page 80 of 283
4.1.14.1. 阻塞队列的主要方法
  抛出异常：抛出一个异常；
  特殊值：返回一个特殊值（null 或 false,视情况而定）
  则塞：在成功操作之前，一直阻塞线程
  超时：放弃前只在最大的时间内阻塞
插入操作：
1：public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行
且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛
出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。
2：public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行
且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。
3：public abstract void put(E paramE) throws InterruptedException： 将指定元素插
入此队列中，将等待可用的空间（如果有必要）
public void put(E paramE) throws InterruptedException {
checkNotNull(paramE);
ReentrantLock localReentrantLock = this.lock;
localReentrantLock.lockInterruptibly();
try {
while (this.count == this.items.length)
this.notFull.await();//如果队列满了，则线程阻塞等待
enqueue(paramE);
13/04/2018  Page 81 of 283
localReentrantLock.unlock();
} finally {
localReentrantLock.unlock();
}
}
4：offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间
内，还不能往队列中加入 BlockingQueue，则返回失败。
获取数据操作 ：
1：poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数
规定的时间,取不到时返回 null;
2：poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在
指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数
据可取，返回失败。
3：take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状
态直到 BlockingQueue 有新的数据被加入。
4.drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个
数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。
4.1.14.2. Java 中的阻塞队列
1.  ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。
2.  LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。
3.  PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。
4.  DelayQueue：使用优先级队列实现的无界阻塞队列。
5.  SynchronousQueue：不存储元素的阻塞队列。
6.  LinkedTransferQueue：由链表结构组成的无界阻塞队列。
7.  LinkedBlockingDeque：由链表结构组成的双向阻塞队列
13/04/2018  Page 82 of 283
4.1.14.3. ArrayBlockingQueue（公平、非公平）
用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下
不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当
队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入
元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐
量。我们可以使用以下代码创建一个公平的阻塞队列：
ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);
4.1.14.4. LinkedBlockingQueue（两个独立锁提高并发）
基于链表的阻塞队列，同ArrayListBlockingQueue类似，此队列按照先进先出（FIFO）的原则对
元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者
端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费
者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。
LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。
4.1.14.5. PriorityBlockingQueue（compareTo 排序实现优先）
是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现
compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造
参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。
4.1.14.6. DelayQueue（缓存失效、定时任务 ）
是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实
现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才
能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景：
1.  缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询
DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。
13/04/2018  Page 83 of 283
2.  定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从
DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。
4.1.14.7. SynchronousQueue（不存储数据、可用于传递数据）
是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。
SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线
程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给
另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和
ArrayBlockingQueue。
4.1.14.8. LinkedTransferQueue
是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，
LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。
1.  transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的
poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如
果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素
被消费者消费了才返回。
2.  tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费
者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否
接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。
对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传
入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时
还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。
4.1.14.9. LinkedBlockingDeque
是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。
双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其
他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，
peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队
列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另
外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同
于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。
在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在
“工作窃取”模式中。
13/04/2018  Page 84 of 283
4.1.15.  CyclicBarrier 、CountDownLatch 、Semaphore 的 的用法 用法
4.1.15.1. CountDownLatch（线程计数器 ）
CountDownLatch类位于java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有
一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch
来实现这种功能了。
final CountDownLatch latch = new CountDownLatch(2);
new Thread(){public void run() {
System.out.println("子线程"+Thread.currentThread().getName()+"正在执行");
Thread.sleep(3000);
System.out.println("子线程"+Thread.currentThread().getName()+"执行完毕");
latch.countDown();
};}.start();
new Thread(){ public void run() {
System.out.println("子线程"+Thread.currentThread().getName()+"正在执行");
Thread.sleep(3000);
System.out.println("子线程"+Thread.currentThread().getName()+"执行完毕");
latch.countDown();
};}.start();
System.out.println("等待 2 个子线程执行完毕...");
latch.await();
System.out.println("2 个子线程已经执行完毕");
System.out.println("继续执行主线程");
}
4.1.15.2. CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）
字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环
是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做
barrier，当调用 await()方法之后，线程就处于 barrier 了。
CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本：
1.  public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任
务；
2.  public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有
线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。
13/04/2018  Page 85 of 283
具体使用如下，另外 CyclicBarrier 是可以重用的。
public static void main(String[] args) {
int N = 4;
CyclicBarrier barrier = new CyclicBarrier(N);
for(int i=0;i<N;i++)
new Writer(barrier).start();
}
static class Writer extends Thread{
private CyclicBarrier cyclicBarrier;
public Writer(CyclicBarrier cyclicBarrier) {
this.cyclicBarrier = cyclicBarrier;
}
@Override
public void run() {
try {
Thread.sleep(5000); //以睡眠来模拟线程需要预定写入数据操作
System.out.println("线程"+Thread.currentThread().getName()+"写入数据完
毕，等待其他线程写入完毕");
cyclicBarrier.await();
} catch (InterruptedException e) {
e.printStackTrace();
}catch(BrokenBarrierException e){
e.printStackTrace();
}
System.out.println("所有线程写入完毕，继续处理其他任务，比如数据操作");
}
}
4.1.15.3. Semaphore（信号量-控制同时访问的线程个数）
S emaphore 翻译成字面意思为 信号量，Semaphore 可以控制同时访问的线程个数，通过
acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。
Semaphore 类中比较重要的几个方法：
1.  public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许
可。
2.  public void acquire(int permits):获取 permits 个许可
3.  public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。
4.  public void release(int permits) { }:释放 permits 个许可
上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法
13/04/2018  Page 86 of 283
1.  public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失
败，则立即返回 false
2.  public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的
时间内获取成功，则立即返回 true，否则则立即返回 false
3.  public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返
回 true，若获取失败，则立即返回 false
4.  public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits
个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false
5.  还可以通过 availablePermits()方法得到可用的许可数目。
例子：若一个工厂有5 台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完
了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现：
int N = 8; //工人数
Semaphore semaphore = new Semaphore(5); //机器数目
for(int i=0;i<N;i++)
new Worker(i,semaphore).start();
}
static class Worker extends Thread{
private int num;
private Semaphore semaphore;
public Worker(int num,Semaphore semaphore){
this.num = num;
this.semaphore = semaphore;
}
@Override
public void run() {
try {
semaphore.acquire();
System.out.println("工人"+this.num+"占用一个机器在生产...");
Thread.sleep(2000);
System.out.println("工人"+this.num+"释放出机器");
semaphore.release();
} catch (InterruptedException e) {
e.printStackTrace();
}
}
  CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不
同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才
13/04/2018  Page 87 of 283
执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时
执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。
  Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。
4.1.16.  volatile 关键字的作用 关键字的作用（变量可见性、禁止重排序） （变量可见性、禁止重排序）
Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他
线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的
地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。
变量可见性
其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的
值对于其他线程是可以立即获取的。
禁止重排序
volatile 禁止了指令重排。
比 sychronized 更轻量级的同步锁
在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一
种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共
享，线程直接给这个变量赋值。
当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有
多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU
cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache
这一步。
适用场景
值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，
但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以
代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场
13/04/2018  Page 88 of 283
景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安
全：
（1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean
flag = true）。
（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不
能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。
4.1.17.  如何在两个线程之间共享数据 如何在两个线程之间共享数据
Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见
性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的
问题，理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法：
将数据抽象成一个类 ，并将数据的操作作为这个类的方法
1.  将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到
同步，只要在方法上加”synchronized“
public class MyData {
private int j=0;
public synchronized void add(){
j++;
System.out.println("线程"+Thread.currentThread().getName()+"j 为："+j);
}
public synchronized void dec(){
j--;
System.out.println("线程"+Thread.currentThread().getName()+"j 为："+j);
}
public int getData(){
return j;
}
}
public class AddRunnable implements Runnable{
MyData data;
public AddRunnable(MyData data){
this.data= data;
}
13/04/2018  Page 89 of 283
public void run() {
data.add();
}
}
public class DecRunnable implements Runnable {
MyData data;
public DecRunnable(MyData data){
this.data = data;
}
public void run() {
data.dec();
}
}
public static void main(String[] args) {
MyData data = new MyData();
Runnable add = new AddRunnable(data);
Runnable dec = new DecRunnable(data);
for(int i=0;i<2;i++){
new Thread(add).start();
new Thread(dec).start();
}
Runnable 对象作为 一个类的内部类
2.  将 Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数
据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各
个 Runnable 对象调用外部类的这些方法。
public class MyData {
private int j=0;
public synchronized void add(){
j++;
System.out.println("线程"+Thread.currentThread().getName()+"j 为："+j);
}
public synchronized void dec(){
j--;
System.out.println("线程"+Thread.currentThread().getName()+"j 为："+j);
}
public int getData(){
return j;
13/04/2018  Page 90 of 283
}
}
public class TestThread {
public static void main(String[] args) {
final MyData data = new MyData();
for(int i=0;i<2;i++){
new Thread(new Runnable(){
public void run() {
data.add();
}
}).start();
new Thread(new Runnable(){
public void run() {
data.dec();
}
}).start();
}
}
}
4.1.18.  ThreadLocal 作用（ 作用（ 线程本地存储 ） ）
ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用
是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或
者组件之间一些公共变量的传递的复杂度。
ThreadLocalMap （线程的一个属性）
1.  每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，
各管各的，线程可以正确的访问到自己的对象。
2.  将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的
ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取
得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。
3.  ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义
ThreadLocal.ThreadLocalMap threadLocals = null;
13/04/2018  Page 91 of 283
使用场景
最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。
private static final ThreadLocal threadSession = new ThreadLocal();
public static Session getSession() throws InfrastructureException {
Session s = (Session) threadSession.get();
try {
if (s == null) {
s = getSessionFactory().openSession();
threadSession.set(s);
}
} catch (HibernateException ex) {
throw new InfrastructureException(ex);
}
return s;
}
4.1.19.  synchronized 和 和 ReentrantLock  的区别
4.1.19.1. 两者的共同点：
1.  都是用来协调多线程对共享对象、变量的访问
2.  都是可重入锁，同一线程可以多次获得同一个锁
3.  都保证了可见性和互斥性
13/04/2018  Page 92 of 283
4.1.19.2. 两者的不同点：
1.  ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁
2.  ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的
不可用性提供了更高的灵活性
3.  ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的
4.  ReentrantLock 可以实现公平锁
5.  ReentrantLock 通过 Condition 可以绑定多个条件
6.  底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻
塞，采用的是乐观并发策略
7.  Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言
实现。
8.  synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，
因此使用 Lock 时需要在 finally 块中释放锁。
9.  Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，
等待的线程会一直等待下去，不能够响应中断。
10. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
11. Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。
4.1.20.  ConcurrentHashMap  并发
4.1.20.1. 减小锁粒度
减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减
小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高
性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我
们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被
称为 ConcurrentHashMap 的并发度。
4.1.20.2. ConcurrentHashMap 分段锁
ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下
一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。
如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首
先根据hashcode得到该表项应该存放在哪个段中，然后对该段加锁，并完成put操作。在多线程
环境中，如果多个线程同时进行put操作，只要被加入的表项不存放在同一个段中，则线程间可以
做到真正的并行。
13/04/2018  Page 93 of 283
ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成
ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可
重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值
对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap
类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是
一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的
数据进行修改时，必须首先获得它对应的 Segment 锁。
4.1.21.  Java  中用到的线程调度
4.1.21.1. 抢占式调度：
抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种
运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至
某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。
4.1.21.2. 协同式调度：
协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，
一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程
本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编
写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。
13/04/2018  Page 94 of 283
4.1.21.3. JVM 的线程调度实现（抢占式调度）
java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高
越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间
片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。
4.1.21.4. 线程让出 cpu 的情况：
1.  当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系
统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。
2.  当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。
3.  当前运行线程结束，即运行完 run()方法里面的任务。
4.1.22.  进程调度算法 进程调度算法
4.1.22.1. 优先调度算法
1.  先来先服务调度算法（FCFS）
当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队
列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采
用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，
13/04/2018  Page 95 of 283
使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较
简单，可以实现基本上的公平。
2.  短作业(进程)优先调度算法
短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们
调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，
将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重
新调度。该算法未照顾紧迫型作业。
4.1.22.2. 高优先权优先调度算法
为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度
算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。
当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。
1.  非抢占式优先权算法
在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下
去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；
也可用于某些对实时性要求不严的实时系统中。
2.  抢占式优先权调度算法
在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只
要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)
的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能
更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批
处理和分时系统中。
2．高响应比优先调度算法
在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行
得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时
间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的
变化规律可描述为：
(1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于
短作业。
(2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权
愈高，因而它实现的是先来先服务。
13/04/2018  Page 96 of 283
(3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其
优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到
达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在
利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。
4.1.22.3. 基于时间片的轮转调度算法
1.  时间片轮转法
在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度
时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行
的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，
并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执
行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处
理机执行时间。
2.  多级反馈队列调度算法
(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二
个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各
不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的
时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长
一倍。
(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当
轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时
尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果
它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个
长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。
(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，
才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优
先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即
由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。
在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间
时，便能够较好的满足各种类型用户的需要。
4.1.23.  什么是 什么是 CAS（ （ 比较并交换-乐观锁机制-锁自旋 ） ）
4.1.23.1. 概念及特性
CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数
CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等
13/04/2018  Page 97 of 283
于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当
前线程什么都不做。最后，CAS 返回当前 V 的真实值。
CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时
使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂
起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，
CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。
4.1.23.2. 原子包 java.util.concurrent.atomic（锁自旋）
JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就
是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个
线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等
到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。
相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切
换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码：
public class AtomicInteger extends Number implements java.io.Serializable {
private volatile int value;
public final int get() {
return value;
}
public final int getAndIncrement() {
for (;;) { //CAS 自旋，一直尝试，直达成功
int current = get();
int next = current + 1;
if (compareAndSet(current, next))
return current;
}
}
public final boolean compareAndSet(int expect, int update) {
return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
}
13/04/2018  Page 98 of 283
getAndIncrement 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行
CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成
CPU 指令的操作。
4.1.23.3. ABA 问题
CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时
刻比较并替换，那么在这个时间差类会导致数据的变化。
比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且
two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操
作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过
程就是没有问题的。
部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修
改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本
号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问
题，因为版本号只会增加不会减少。
4.1.24.  什么是 什么是 AQS（ （ 抽象的队列同步器 ） ）
AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问
共享资源的同步器框架，许多同步类实现都依赖于它，如常用的
ReentrantLock/Semaphore/CountDownLatch。
13/04/2018  Page 99 of 283
它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被
阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的
访问方式有三种:
getState()
setState()
compareAndSetState()
AQS 定义两种资源共享方式
Exclusive 独占资源 -ReentrantLock
Exclusive（独占，只有一个线程能执行，如 ReentrantLock）
Share 共享资源 -Semaphore/CountDownLatch
Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。
AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS这里只定义了一个
接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS)之所以没有定义成
abstract，是因为独占模式下只用实现 tryAcquire-tryRelease，而共享模式下只用实现
tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模
式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实
现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/
唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：
1． isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。
2． tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。
3． tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。
4． tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余
可用资源；正数表示成功，且有剩余资源。
5． tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回
true，否则返回 false。
13/04/2018  Page 100 of 283
同步器 的实现是 ABS 核心（ state 资源状态计数）
同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程
lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失
败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放
锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，
获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。
以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与
线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state
会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程
就会从 await()函数返回，继续后余动作。
ReentrantReadWriteLock 实现独占和共享两种 方式
一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-
tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器
同时实现独占和共享两种方式，如 ReentrantReadWriteLock。
13/04/2018  Page 101 of 283
5. JAVA  基础
5.1.1. JAVA  异常分类及处理
5.1.1.1.  概念
如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下
会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用
这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。
5.1.1.2.  异常分类
Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception
Error
1.  Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果
出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。
Exception （ RuntimeException、CheckedException ）
2.  Exception 又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个 是
CheckedException。
RuntimeException 如 ： NullPointerException 、 ClassCastException ； 一 个 是 检 查 异 常
CheckedException，如 I/O 错误导致的 IOException、SQLException。 RuntimeException 是
那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一
定是程序员的错误.
13/04/2018  Page 102 of 283
检查异常 CheckedException：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强
制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一
般包括几个方面：
1.  试图在文件尾部读取数据
2.  试图打开一个错误格式的 URL
3.  试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在
5.1.1.3.  异常的处理方式
遇到问题不进行具体处理，而是继续抛给调用者 （ throw,throws ）
抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。
public static void main(String[] args) {
String s = "abc";
if(s.equals("abc")) {
throw new NumberFormatException();
} else {
System.out.println(s);
}
}
int div(int a,int b) throws Exception{
return a/b;}
try catch  捕获异常针对性处理方式
5.1.1.4.  Throw 和 throws 的区别：
位置不同
1.  throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的
是异常对象。
功能不同：
2.  throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方
式；throw抛出具体的问题对象，执行到throw，功能就已经结束了，跳转到调用者，并
将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语
句，因为执行不到。
3.  throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，
执行 throw 则一定抛出了某种异常对象。
13/04/2018  Page 103 of 283
4.  两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异
常，真正的处理异常由函数的上层调用处理。
5.1.2. JAVA  反射
5.1.2.1.  动态语言
动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结
构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，
而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。
5.1.2.2.  反射机制概念 （运行状态中知道类所有的属性和方法）
在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；
并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方
法的功能成为 Java 语言的反射机制。
5.1.2.3.  反射的应用场合
编译时类型和运行时类型
在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由
声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：
Person p=new Student();
其中编译时类型为 Person，运行时类型为 Student。
13/04/2018  Page 104 of 283
的编译时类型无 法获取具体方法
程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用
该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。
然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象
和类的真实信息，此时就必须使用到反射了。
5.1.2.4.  Java 反射 API
反射 API 用来生成 JVM 中的类、接口或则对象的信息。
1.  Class 类：反射的核心类，可以获取类的属性，方法等信息。
2.  Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性
值。
3.  Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或
者执行方法。
4.  Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法。
5.1.2.5.  反射使用步骤（获取 Class 对象、调用对象方法）
1.  获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方
法。
2.  调用 Class 类中的方法，既就是反射的使用阶段。
3.  使用反射 API 来操作这些信息。
5.1.2.6.  获取 Class 对象的 3 种方法
调用某个对象的 getClass() 方法
Person p=new Person();
Class clazz=p.getClass();
调用某个类的 class 属性来获取该类对应的 Class 对象
Class clazz=Person.class;
使用 Class 类中的 forName() 静态方法 ( 最安全 / 性能最好 )
Class clazz=Class.forName("类的全路径"); (最常用)
当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法
和属性。
//获取 Person 类的 Class 对象
Class clazz=Class.forName("reflection.Person");
13/04/2018  Page 105 of 283
//获取 Person 类的所有方法信息
Method[] method=clazz.getDeclaredMethods();
for(Method m:method){
System.out.println(m.toString());
}
//获取 Person 类的所有成员属性信息
Field[] field=clazz.getDeclaredFields();
for(Field f:field){
System.out.println(f.toString());
}
//获取 Person 类的所有构造方法信息
Constructor[] constructor=clazz.getDeclaredConstructors();
for(Constructor c:constructor){
System.out.println(c.toString());
}
5.1.2.7.  创建对象的两种方法
Class 对象的 newInstance()
1.  使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求
该 Class 对象对应的类有默认的空构造器。
调用 Constructor 对象的 newInstance()
2.  先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()
方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。
//获取 Person 类的 Class 对象
Class clazz=Class.forName("reflection.Person");
//使用.newInstane 方法创建对象
Person p=(Person) clazz.newInstance();
//获取构造方法并创建对象
Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class);
//创建对象并设置属性
13/04/2018  Page 106 of 283
Person p1=(Person) c.newInstance("李四","男",20);
5.1.3. JAVA  注解
5.1.3.1.  概念 概念
A nnotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径
和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation
对象，然后通过该 Annotation 对象来获取注解中的元数据信息。
5.1.3.2.  4 种标准 种标准元注解 元注解
元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被
用来提供对其它 annotation 类型作说明。
@Target 修饰的对象范围
@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、
接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数
和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰
其修饰的目标
@Retention 定义 被保留的时间长短
Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描
述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：
  SOURCE:在源文件中有效（即源文件保留）
  CLASS:在 class 文件中有效（即 class 保留）
  RUNTIME:在运行时有效（即运行时保留）
@Documented  描述-javadoc
@ Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因
此可以被例如 javadoc 此类的工具文档化。
@Inherited  阐述了某个被标注的类型是被继承的
@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一
个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该
class 的子类。
13/04/2018  Page 107 of 283
5.1.3.3.  注解处理器 处理器
如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，
很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速
的构造自定义注解处理器。下面实现一个注解处理器。
/1：*** 定义注解*/
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {
/**供应商编号*/
public int id() default -1;
/*** 供应商名称*/
public String name() default ""；
13/04/2018  Page 108 of 283
/** * 供应商地址*/
public String address() default "";
}
//2：注解使用
public class Apple {
@FruitProvider(id = 1, name = "陕西红富士集团", address = "陕西省西安市延安路")
private String appleProvider;
public void setAppleProvider(String appleProvider) {
this.appleProvider = appleProvider;
}
public String getAppleProvider() {
return appleProvider;
}
}
/3：*********** 注解处理器 ***************/
public class FruitInfoUtil {
public static void getFruitInfo(Class<?> clazz) {
String strFruitProvicer = "供应商信息：";
Field[] fields = clazz.getDeclaredFields();//通过反射获取处理注解
for (Field field : fields) {
if (field.isAnnotationPresent(FruitProvider.class)) {
FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class);
//注解信息的处理地方
strFruitProvicer = " 供应商编号：" + fruitProvider.id() + " 供应商名称："
+ fruitProvider.name() + " 供应商地址："+ fruitProvider.address();
System.out.println(strFruitProvicer);
}
}
}
}
13/04/2018  Page 109 of 283
public class FruitRun {
public static void main(String[] args) {
FruitInfoUtil.getFruitInfo(Apple.class);
/***********输出结果***************/
// 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延
}
}
5.1.4. JAVA  内部类
Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根
据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。
5.1.4.1.  静态内部类 静态内部类
定义在类内部的静态类，就是静态内部类。
public class Out {
private static int a;
private int b;
public static class Inner {
public void print() {
System.out.println(a);
}
}
}
1.  静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。
2.  静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。
3.  其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：Out.Inner inner =
new Out.Inner();inner.print();
4.  Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，
HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部
类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。
13/04/2018  Page 110 of 283
5.1.4.2.  成员内部类 内部类
定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final 修饰的
除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内
部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。
public class Out {
private static int a;
private int b;
public class Inner {
public void print() {
System.out.println(a);
System.out.println(b);
}
}
}
5.1.4.3.  局部 内部类 （ 定义在方法中的类） ）
定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。
public class Out {
private static int a;
private int b;
public void test(final int c) {
final int d = 1;
class Inner {
public void print() {
System.out.println(c);
}
}
}
}
13/04/2018  Page 111 of 283
5.1.4.4.  匿名 内部类 （ 要继承一个父类或者实现一个接口、直接使用
new 来生成一个对象的引用 来生成一个对象的引用） ）
匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一
个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引
用。
public abstract class Bird {
private String name;
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public abstract int fly();
}
public class Test {
public void test(Bird bird){
System.out.println(bird.getName() + "能够飞 " + bird.fly() + "米");
}
public static void main(String[] args) {
Test test = new Test();
test.test(new Bird() {
public int fly() {
return 10000;
}
public String getName() {
return "大雁";
}
});
}
}
13/04/2018  Page 112 of 283
5.1.5. JAVA  泛型
泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本
质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法，
能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。
5.1.5.1.  泛型方法（ （<E>） ）
你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数
类型，编译器适当地处理每一个方法调用。
// 泛型方法 printArray
public static < E > void printArray( E[] inputArray )
{
for ( E element : inputArray ){
System.out.printf( "%s ", element );
}
}
1.  <? extends T>表示该通配符所代表的类型是 T 类型的子类。
2.  <? super T>表示该通配符所代表的类型是 T 类型的父类。
5.1.5.2.  泛型类 泛型类<T>
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一
样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，
也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，
这些类被称为参数化的类或参数化的类型。
public class Box<T> {
private T t;
public void add(T t) {
this.t = t;
}
public T get() {
return t;
}
13/04/2018  Page 113 of 283
5.1.5.3.  类型通配符 类型通配符?
类 型 通 配 符 一 般 是 使 用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List<?> 在 逻 辑 上 是
List<String>,List<Integer> 等所有 List<具体类型实参>的父类。
5.1.5.4.  类型擦除 类型擦除
Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛
型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个
过程就称为类型擦除。如在代码中定义的 List<Object>和 List<String>等类型，在编译之后
都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。
类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般
是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换
成具体的类。
5.1.6. JAVA  序列化( 创建可复用的 Java  对象)
保存 ( 持久化 ) 对象 及其状态到内存或者磁盘
Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，
这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，
就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。
Java 对象序列化就能够帮助我们实现该功能。
序列化对象以字节数组保持 - 静态成员不保存
使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装
成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对
象序列化不会关注类中的静态变量。
序列化用户远程对象传输
除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，
都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。
Serializable 实现序列化
在 Java 中，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。
ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化
通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。
writeObject  和 readObject 自定义序列化策略
在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。
序列化 ID
虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个
类的序列化 ID 是否一致（就是 private static final long serialVersionUID）
13/04/2018  Page 114 of 283
序列化并不保存静态变量
序列化子父类说明
要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。
Transient 关键字 阻止该变量被序列化到文件中
1.  在变量声明前加上 Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列
化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。
2.  服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串
等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在
客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的
数据安全。
5.1.7. JAVA  复制
将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式
是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。
5.1.7.1.  直接赋值复制
直接赋值。在 Java 中，A a1 = a2，我们需要理解的是这实际上复制的是引用，也就是
说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟
着变化。
5.1.7.2.  浅复制（复制引用但不复制引用的对象）
创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，
那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。
因此，原始对象及其副本引用同一个对象。
class Resume implements Cloneable{
public Object clone() {
try {
return (Resume)super.clone();
} catch (Exception e) {
e.printStackTrace();
return null;
}
}
}
13/04/2018  Page 115 of 283
5.1.7.3.  深复制（复制对象和其应用对象）
深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。
class Student implements Cloneable {
String name;
int age;
Professor p;
Student(String name, int age, Professor p) {
this.name = name;
this.age = age;
this.p = p;
}
public Object clone() {
Student o = null;
try {
o = (Student) super.clone();
} catch (CloneNotSupportedException e) {
System.out.println(e.toString());
}
o.p = (Professor) p.clone();
return o;
}
}
5.1.7.4.  序列化（深 clone 一中实现）
在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对
象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。
13/04/2018  Page 116 of 283
6. Spring  原理
它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是 Spring
仍然可以和其他的框架无缝整合。
6.1.1. Spring  特点
6.1.1.1.  轻量级
6.1.1.2.  控制反转
6.1.1.3.  面向切面
6.1.1.4.  容器
6.1.1.5.  框架集合
13/04/2018  Page 117 of 283
6.1.2. Spring  核心组件
6.1.3. Spring  常用模块
13/04/2018  Page 118 of 283
6.1.4. Spring  主要包
6.1.5. Spring  常用注解
bean 注入与装配的的方式有很多种，可以通过 xml，get set 方式，构造函数或者注解等。简单易
用的方式就是使用 Spring 的注解了，Spring 提供了大量的注解方式。
13/04/2018  Page 119 of 283
6.1.6. Spring  第三方结合
13/04/2018  Page 120 of 283
6.1.7. Spring IOC  原理
6.1.7.1.  概念 概念
Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化
Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供
了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。
6.1.7.2.  Spring  容器高层视图
Spring 启动时读取应用程序提供的 Bean 配置信息，并在 Spring 容器中生成一份相应的 Bean 配
置注册表，然后根据这张注册表实例化 Bean，装配好 Bean 之间的依赖关系，为上层应用提供准
备就绪的运行环境。其中 Bean 缓存池为 HashMap 实现
6.1.7.3.  IOC  容器实现
BeanFactory- 框架基础设施
BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用
Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层
的 BeanFactory。
13/04/2018  Page 121 of 283
1.1..1.1.1  BeanDefinitionRegistry 注册表
1.  Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，
它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册
BeanDefinition 对象的方法。
1.1..1.1.2  BeanFactory  顶层接口
2.  位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中
返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展：
1.1..1.1.3  ListableBeanFactory
3.  该接口定义了访问容器中 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型
Bean 的配置名、查看容器中是否包括某一 Bean 等方法；
1.1..1.1.4  HierarchicalBeanFactory 父子级联
4.  父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过
HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子
容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实
现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久
层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务
层和持久层的 Bean 则看不到展现层的 Bean。
1.1..1.1.5  ConfigurableBeanFactory
5.  是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容
器初始化后置处理器等方法；
13/04/2018  Page 122 of 283
1.1..1.1.6  AutowireCapableBeanFactory 自动装配
6.  定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；
1.1..1.1.7  SingletonBeanRegistry 运行期间注册单例 Bean
7.  定义了允许在运行期间向容器注册单实例 Bean 的方法；对于单实例（ singleton）的 Bean
来说，BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从
IoC 容器的缓存中获取 Bean 实例。Spring 在 DefaultSingletonBeanRegistry 类中提供了一
个用于缓存单实例 Bean 的缓存器，它是一个用 HashMap 实现的缓存器，单实例的 Bean 以
beanName 为键保存在这个 HashMap 中。
1.1..1.1.8  依赖日志框框
8.  在初始化 BeanFactory 时，必须为其提供一种日志框架，比如使用 Log4J， 即在类路径下提
供 Log4J 配置文件，这样启动 Spring 容器才不会报错。
ApplicationContext 面向开发应用
ApplicationContext 由 BeanFactory 派 生 而 来 ， 提 供 了 更 多 面 向 实 际 应 用 的 功 能 。
ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础
上，还通过多个其他的接口扩展了 BeanFactory 的功能：
1.  ClassPathXmlApplicationContext：默认从类路径加载配置文件
13/04/2018  Page 123 of 283
2.  FileSystemXmlApplicationContext：默认从文件系统中装载配置文件
3.  ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事
件、关闭事件等。
4.  MessageSource：为应用提供 i18n 国际化消息访问的功能；
5.  ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于
PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文
件路径装载 Spring 的配置文件。
6.  LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要
用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体
Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接
口的 Bean，以达到管理和控制 JMX、任务调度等目的。
7.  ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要
的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下
文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动
的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用 close()则可关闭应用
上下文。
WebApplication 体系架构
WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的
路径中装载配置文件完成初始化工作。从 WebApplicationContext 中可以获得
ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext
中，以便 Web 应用环境可以访问 Spring 应用上下文。
6.1.7.4.  Spring Bean  作用域
Spring 3 中为 Bean 定义了 5 中作用域，分别为 singleton（单例）、prototype（原型）、
request、session 和 global session，5 种作用域说明如下：
singleton ：单例模式 （多线程下不安全）
1.  singleton：单例模式，Spring IoC 容器中只会存在一个共享的 Bean 实例，无论有多少个
Bean 引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton 作用域是
Spring 中的缺省作用域，也可以显示的将 Bean 定义为 singleton 模式，配置为：
<bean id="userDao" class="com.ioc.UserDaoImpl" scope="singleton"/>
13/04/2018  Page 124 of 283
prototype: 原型模式 每次使用时创建
2.  prototype:原型模式，每次通过 Spring 容器获取 prototype 定义的 bean 时，容器都将创建
一个新的 Bean 实例，每个 Bean 实例都有自己的属性和状态，而 singleton 全局只有一个对
象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton
作用域。
Request ：一次 request 一个实例
3.  request：在一次 Http 请求中，容器会返回该 Bean 的同一实例。而对不同的 Http 请求则会
产生新的 Bean，而且该 bean 仅在当前 Http Request 内有效,当前 Http 请求结束，该 bean
实例也将会被销毁。
<bean id="loginAction" class="com.cnblogs.Login" scope="request"/>
session
4.  session：在一次 Http Session 中，容器会返回该 Bean 的同一实例。而对不同的 Session 请
求则会创建新的实例，该 bean 实例仅在当前 Session 内有效。同 Http 请求相同，每一次
session 请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的 session 请求
内有效，请求结束，则实例将被销毁。
<bean id="userPreference" class="com.ioc.UserPreference" scope="session"/>
global Session
5.  global Session：在一个全局的 Http Session 中，容器会返回该 Bean 的同一个实例，仅在
使用 portlet context 时有效。
6.1.7.5.  Spring Bean  生命周期
实例化
1.  实例化一个 Bean，也就是我们常说的 new。
IOC 依赖注入
2.  按照 Spring 上下文对实例化的 Bean 进行配置，也就是 IOC 注入。
setBeanName 实现
3.  如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String)
方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值
BeanFactoryAware 实现
4.  如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory，
setBeanFactory(BeanFactory)传递的是 Spring 工厂自身（可以用这个方式来获取其它 Bean，
只需在 Spring 配置文件中配置一个普通的 Bean 就可以）。
13/04/2018  Page 125 of 283
ApplicationContextAware 实现
5.  如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用
setApplicationContext(ApplicationContext)方法，传入 Spring 上下文（同样这个方式也
可以实现步骤 4 的内容，但比 4 更好，因为 ApplicationContext 是 BeanFactory 的子接
口，有更多的实现方法）
postProcessBeforeInitialization 接口实现 - 初始化预处理
6.  如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用
postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor 经常被用
作是 Bean 内容的更改，并且由于这个是在 Bean 初始化结束时调用那个的方法，也可以被应
用于内存或缓存技术。
init-method
7.  如果 Bean 在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法。
postProcessAfterInitialization
8.  如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用
postProcessAfterInitialization(Object obj, String s)方法。
注：以上工作完成以后就可以应用这个 Bean 了，那这个 Bean 是一个 Singleton 的，所以一
般情况下我们调用同一个 id 的 Bean 会是在内容地址相同的实例，当然在 Spring 配置文件中
也可以配置非 Singleton。
Destroy 过期自动 清理阶段
9.  当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调
用那个其实现的 destroy()方法；
destroy-method 自配置清理
10. 最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的
销毁方法。
13/04/2018  Page 126 of 283
11. bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你可以自己定制
初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。
<bean id="" class="" init-method="初始化方法" destroy-method="销毁方法">
6.1.7.6.  Spring  依赖注入四种方式
构造器注入
/*带参数，方便利用构造器进行注入*/
public CatDaoImpl(String message){
this. message = message;
}
<bean id="CatDaoImpl" class="com.CatDaoImpl">
<constructor-arg value=" message "></constructor-arg>
</bean>
13/04/2018  Page 127 of 283
setter 方法 注入
public class Id {
private int id;
public int getId() { return id; }
public void setId(int id) { this.id = id; }
}
<bean id="id" class="com.id "> <property name="id" value="123"></property> </bean>
静态工厂注入
静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 spring 管理所
有对象，我们不能直接通过"工程类.静态方法()"来获取对象，而是依然通过 spring 注入的形式获
取：
public class DaoFactory { //静态工厂
public static final FactoryDao getStaticFactoryDaoImpl(){
return new StaticFacotryDaoImpl();
}
}
public class SpringAction {
private FactoryDao staticFactoryDao; //注入对象
//注入对象的 set 方法
public void setStaticFactoryDao(FactoryDao staticFactoryDao) {
this.staticFactoryDao = staticFactoryDao;
}
}
//factory-method="getStaticFactoryDaoImpl"指定调用哪个工厂方法
<bean name="springAction" class=" SpringAction" >
<!--使用静态工厂的方法注入对象,对应下面的配置文件-->
<property name="staticFactoryDao" ref="staticFactoryDao"></property>
</bean>
<!--此处获取对象的方式是从工厂类中获取静态方法-->
<bean name="staticFactoryDao" class="DaoFactory"
factory-method="getStaticFactoryDaoImpl"></bean>
实例工厂
